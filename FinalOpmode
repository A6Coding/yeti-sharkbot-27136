package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.TouchSensor;
import org.firstinspires.ftc.robotcore.external.navigation.CurrentUnit;
import org.firstinspires.ftc.robotcore.external.Telemetry;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;

@TeleOp(name = "FinalOpmode")
public class FinalOpmode extends LinearOpMode {

  private DcMotor frontLeft;
  private DcMotor frontRight;
  private DcMotor backLeft;
  private DcMotor backRight;
  private CRServo intakeServo;
  private DcMotor motorArm;
  private DcMotor motorSlide;
  private TouchSensor sensorTouch;
  
  
  @Override
  public void runOpMode() {
    frontLeft = hardwareMap.get(DcMotor.class, "frontLeft");
    backLeft = hardwareMap.get(DcMotor.class, "backLeft");
    frontRight = hardwareMap.get(DcMotor.class, "frontRight");
    backRight = hardwareMap.get(DcMotor.class, "backRight");
    motorArm = hardwareMap.get(DcMotor.class, "motorArm");
    motorSlide = hardwareMap.get(DcMotor.class, "motorSlide");
    intakeServo = hardwareMap.get(CRServo.class, "intakeServo");
    sensorTouch = hardwareMap.get(TouchSensor.class, "sensorTouch");
    
    int mins;
    int maxs;
    int max;
    int min;
    int pivot;
    int horizontal;
    int vertical;
    String power;
    String slide;
    
    waitForStart();
    motorArm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    motorSlide.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    
    frontLeft.setDirection(DcMotor.Direction.REVERSE);
    backLeft.setDirection(DcMotor.Direction.REVERSE);
    backRight.setDirection(DcMotor.Direction.REVERSE);
    
    motorArm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    motorArm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    
    motorSlide.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    motorSlide.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    maxs = -2600;
    max = 2600;
    mins = 0;
    min = 0;
    power = "pls work";
    
    slide = "pls work";
    
    waitForStart();
    
    if(opModeIsActive()) {
      
    }
    
    while (opModeIsActive()) {
      telemetry.addData("Arm Position", motorArm.getCurrentPosition());
      telemetry.addData("Slide Position", motorSlide.getCurrentPosition());
      telemetry.update();
      
      vertical = (int)gamepad1.left_stick_y;
      horizontal = (int)gamepad1.left_stick_x;
      pivot = (int)gamepad1.right_stick_x;
      
      //Movement
      frontRight.setPower((-vertical - (pivot -horizontal))/1.5);
      backRight.setPower((-vertical-(pivot +horizontal))/1.5);
      frontLeft.setPower((-vertical+(pivot -horizontal))/1.5);
      backLeft.setPower((-vertical+(pivot +horizontal))/1.5);
      //Movement
      
      
      //Arm
      if(motorArm.getCurrentPosition()>max-60) {
        power = "stop";
        motorArm.setPower(0.25);
        sleep(100);
        motorArm.setPower(0);
      } else if(gamepad2.left_stick_y>0 || gamepad2.left_stick_y<0) {
        power = "x";
      } else {
        power = "b";
      }
      
      if(power == "b" && motorSlide.getCurrentPosition()<-1000) {
        if(motorArm.getCurrentPosition()<3000) {
        motorArm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        motorArm.setPower(-0.07);
        }
      }
      else if(power == "b") {
        if(motorArm.getCurrentPosition()<3000)
        motorArm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        motorArm.setPower(-0.05);
      }
      if(power =="x") {
        motorArm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        motorArm.setPower(gamepad2.left_stick_y);
      }
      //Arm
      
      
      //Intake
      if(gamepad2.left_trigger>0) {
        intakeServo.setPower(gamepad2.left_trigger);
      } else if(gamepad2.right_trigger>0) {
        intakeServo.setPower(-gamepad2.right_trigger);
      } else{
        intakeServo.setPower(0);
      } 
      //Intake
      
      
      //Linear Slide
      if(motorSlide.getCurrentPosition() < maxs+180) {
        slide = "extended";
        motorSlide.setPower(-0.25);
        sleep(100);
        motorSlide.setPower(0);
      } 
      else if(gamepad2.right_stick_y>0 || gamepad2.right_stick_y<0) {
        slide = "x";
      } else {
        slide = "b";
      }
      
      if(slide == "b") {
        motorSlide.setPower(0);
      }
      if(slide =="x") {
        motorSlide.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        motorSlide.setPower(-gamepad2.right_stick_y);
      }
      //Linear Slide
      
      //Hang
      if(gamepad2.back) {
        power = "hang";
        while (opModeIsActive()) {
        motorArm.setPower(0.75);
        }
      
    }}
  }}
